gem 'json'
require 'json'

def pad_str(count, str)
  str.lines.map{|line| "#{" "*count}#{line.lstrip}" }.join()
end

def titleize(name)
  name[0].upcase+name[1..-1]
end

def normalize_argument(argument_name)
  argument_name.tr("-","_").gsub(/^type$/, "_type")
end

def normalize_method(klass)
  klass.gsub(/(\-.)/){|c| c[1].upcase}
end

def map_type_to_rust(type)
  case type
  when "octet"
    "u8"
  when "long"
    "u32"
  when "longlong"
    "u64"
  when "short"
    "u16"
  when "bit"
    'bool'
  when "shortstr"
    # 'Vec<u8>'
    String
  when "longstr"
    # 'Vec<u8>'
    String
  when "table"
    "Table"
  when "timestamp"
    "u64"
  else
    raise "Uknown type: #{type}"
  end
end

def read_type(type)
  case type
  when "octet"
    "try!(reader.read_byte())"
  when "long"
    "try!(reader.read_be_u32())"
  when "longlong"
    "try!(reader.read_be_u64())"
  when "short"
    "try!(reader.read_be_u16())"
  when "bit"
    raise "Cant read bit here..."
  when "shortstr"
    "{
        let size = try!(reader.read_byte()) as uint;
        String::from_utf8_lossy(try!(reader.read_exact(size)).as_slice()).into_string()
     }"
  when "longstr"
    "{
       let size = try!(reader.read_be_u32()) as uint;
       String::from_utf8_lossy(try!(reader.read_exact(size)).as_slice()).into_string()
      }"
  when "table"
    "try!(decode_table(&mut reader))"
  when "timestamp"
    "try!(reader.read_be_u64())"
  else
    raise "Unknown type: #{type}"
  end
end

def write_type(name, type)
  case type
  when "octet"
    "writer.write_u8(self.#{name}).unwrap();"
  when "long"
    "writer.write_be_u32(self.#{name}).unwrap();"
  when "longlong"
    "writer.write_be_u64(self.#{name}).unwrap();"
  when "short"
    "writer.write_be_u16(self.#{name}).unwrap();"
  when "bit"
    raise "Cant write bit here..."
  when "shortstr"
    "writer.write_u8(self.#{name}.len() as u8).unwrap();
    writer.write(self.#{name}.as_bytes()).unwrap();"
  when "longstr"
    "writer.write_be_u32(self.#{name}.len() as u32).unwrap();
    writer.write(self.#{name}.as_bytes()).unwrap();"
  when "table"
    "encode_table(&mut writer, self.#{name}.clone()).unwrap();"
  when "timestamp"
    "writer.write_be_u64(self.#{name}).unwrap();"
  else
    raise "Unknown type: #{type}"
  end
end

def map_domain(domain)
  DOMAINS[domain]
end

def generate_reader_body(arguments)
    puts "        let mut reader = MemReader::new(method_frame.arguments);"
    n_bits = 0
    arguments.each do |argument|
      type = argument["domain"] ? map_domain(argument["domain"]) : argument["type"]
      if type == "bit"
        if n_bits == 0
          puts pad_str(8, "let byte = try!(reader.read_byte());")
          puts pad_str(8, "let bits = bitv::from_bytes([byte]);")
        end
        puts pad_str(8, "let #{normalize_argument(argument["name"])} = bits.get(#{n_bits});")
        n_bits += 1
        if n_bits == 8
          n_bits = 0
        end
      else
        n_bits = 0
        puts pad_str(8, "let #{normalize_argument(argument["name"])} = #{read_type(type)};")
      end
    end
end

def generate_writer_body(arguments)
    puts "        let mut writer = MemWriter::new();"
    n_bits = 0
    arguments.each do |argument|
      type = argument["domain"] ? map_domain(argument["domain"]) : argument["type"]
      if type == "bit"
        if n_bits == 0
          puts pad_str(8, "let mut bits = Bitv::new();")
        end
        puts pad_str(8, "bits.push(self.#{normalize_argument(argument["name"])});")
        n_bits += 1
      else
        if n_bits > 0
          puts pad_str(8, "writer.write(bits.to_bytes().as_slice()).unwrap();")
          n_bits = 0
        end
        puts pad_str(8, write_type(normalize_argument(argument["name"]), type))
      end
    end
    puts pad_str(8, "writer.write(bits.to_bytes().as_slice()).unwrap();") if n_bits > 0 #if bits were the last element
    puts pad_str(8, "writer.unwrap()")
end

spec_file = 'amqp-rabbitmq-0.9.1.json'
SPEC = JSON.load(File.read(spec_file))
DOMAINS = Hash[SPEC["domains"]]


puts "// This file is autogenerated. Do not edit.
// To make some changes, edit codegen.rb and run make\n"

puts <<-RUST

use std::io::IoResult;

pub trait Method {
    fn decode(method_frame: MethodFrame) -> IoResult<Self>;
    fn encode(&self) -> Vec<u8>;
    fn name(&self) -> &'static str;
    fn id(&self) -> u16;
    fn class_id(&self) -> u16;
}

#[deriving(Show, Clone)]
pub struct MethodFrame {
    pub class_id: u16,
    pub method_id: u16,
    pub arguments: Vec<u8>
}

impl MethodFrame {
    pub fn method_name(&self) -> &'static str {
        match (self.class_id, self.method_id) {
RUST
matches = SPEC["classes"].flat_map do |klass|
  klass["methods"].map do |method|
    "(#{klass["id"]}, #{method["id"]}) => \"#{klass["name"]}.#{method["name"]}\""
  end
end
matches << "(_,_) => \"UNKNOWN\""
puts pad_str(12, matches.join(",\n"))

puts <<-RUST
        }
    }
}

#[deriving(Show, Clone)]
pub struct ContentHeaderFrame {
    pub content_class: u16,
    pub weight: u16,
    pub body_size: u64,
    pub properties_flags: u16,
    pub properties: Vec<u8>
}

RUST

SPEC["classes"].each do |klass|
  struct_name = titleize(klass["name"])
  puts "#[allow(unused_imports)]"
  puts "pub mod #{klass["name"]} {"
  puts "use std::collections::bitv;"
  puts "use std::collections::bitv::Bitv;"
  puts "use std::io::{MemReader, MemWriter, InvalidInput, IoResult, IoError};"
  puts
  puts "use table::{Table, decode_table, encode_table};"
  puts "use protocol;"
  puts "use protocol::Method;"
  puts

  #properties struct definition
  if klass["properties"]
    props = klass["properties"].map do |prop|
      rust_type = map_type_to_rust prop["domain"] ? map_domain(prop["domain"]) : prop["type"]
      "pub #{normalize_argument prop["name"]}: Option<#{rust_type}>"
    end
    puts "//properties struct for #{klass["name"]}"
    properties_struct_name = "#{struct_name}Properties"
    if klass["properties"].any?
      puts "#[deriving(Show, Default)]"
      puts "pub struct #{properties_struct_name} {"
      puts pad_str(4, props.join(",\n"))
      puts "}"
      puts
      puts "impl #{properties_struct_name} {"
      puts "    pub fn decode(content_header_frame: protocol::ContentHeaderFrame) -> IoResult<#{properties_struct_name}> {"
      puts "        let mut reader = MemReader::new(content_header_frame.properties);"
      puts "        let properties_flags = bitv::from_bytes([((content_header_frame.properties_flags >> 8) & 0xff) as u8,
        (content_header_frame.properties_flags & 0xff) as u8]);"
      klass["properties"].each.with_index do |prop, idx|
        prop_name = normalize_argument prop["name"]
        puts pad_str(8, "let #{prop_name} = if properties_flags.get(#{idx}) {")
          type = prop["domain"] ? map_domain(prop["domain"]) : prop["type"]
          puts pad_str(12, "Some(#{read_type(type)})")
        puts pad_str(8, "} else {")
          puts pad_str(12, "None")
        puts pad_str(8, "};")
      end
      fields = klass["properties"].map{|arg| "#{normalize_argument arg["name"]}: #{normalize_argument arg["name"]}"}
      puts "        Ok(#{properties_struct_name} { #{fields.join(", ")} })"
      puts "    }"
      puts "}"
    else
      puts "pub struct #{struct_name}Properties;"
    end
  end


  klass["methods"].each do |method|
    method_name = normalize_method titleize(method["name"])
    properties = method["properties"]
    arguments = method["arguments"]

    fields = arguments.map do |argument|
      rust_type = map_type_to_rust argument["domain"] ? map_domain(argument["domain"]) : argument["type"]
      "pub #{normalize_argument argument["name"]}: #{rust_type}"
    end

    puts "// Method #{method["id"]}:#{method["name"]}"
    puts "#[deriving(Show)]"
    if fields.any?
      puts "pub struct #{method_name} {"
      puts pad_str(4, fields.join(",\n"))
      puts "}"
    else
      puts "pub struct #{method_name};"
    end

    #impl Method for struct
    puts "impl Method for #{method_name} {"
    puts "    fn name(&self) -> &'static str {"
    puts "        \"#{klass["name"]}.#{method["name"]}\""
    puts "    }"
    puts "    fn id(&self) -> u16 {"
    puts "        #{method["id"]}"
    puts "    }"
    puts "    fn class_id(&self) -> u16 {"
    puts "        #{klass["id"]}"
    puts "    }"

    #Decode
    puts "    fn decode(method_frame: protocol::MethodFrame) -> IoResult<#{method_name}> {"
    puts "        if method_frame.class_id != #{klass["id"]} || method_frame.method_id != #{method["id"]} {"
    puts "           return Err(IoError{kind: InvalidInput, desc: \"Frame class_id & method_id didn't match\", detail: None});"
    puts "        }"
    if arguments.any?
      generate_reader_body(arguments)
      fields = arguments.map{|arg| "#{normalize_argument arg["name"]}: #{normalize_argument arg["name"]}"}
      puts "        Ok(#{method_name} { #{fields.join(", ")} })"
    else
      puts "        Ok(#{method_name})"
    end
    puts "    }"

    #Encode
    puts "    fn encode(&self) -> Vec<u8> {"
    if arguments.any?
      generate_writer_body(arguments)
    else
      puts(pad_str(8, "vec!()"))
    end
    puts pad_str(4, "}")

    puts "}"
  end
  puts "}"
end
